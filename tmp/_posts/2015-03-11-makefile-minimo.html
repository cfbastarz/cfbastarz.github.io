---
layout: post
title: Makefile (mínimo!)
date: 2015-03-11 02:14:05.000000000 -03:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Tudo
- Tutoriais
tags:
- fortran
- Makefile
- Shell
meta:
  _edit_last: '13386696'
  geo_public: '0'
  _thumbnail_id: '2422'
  _oembed_d1acc1b547b4dc5c5540804135dddc45: "{{unknown}}"
  _oembed_03a31a9cdf15aaac29f0a3b6e362d1c5: "{{unknown}}"
  _oembed_150a7eeda995af15d331d16b33dd98c0: "{{unknown}}"
  _publicize_job_id: '19172246963'
author:
  login: craftmind
  email: cfbastarz@gmail.com
  display_name: cfbastarz
  first_name: ''
  last_name: ''
permalink: "/2015/03/11/makefile-minimo/"
---
<p>Quem trabalha com programação sabe que é necessário manter tudo em ordem: não importa se o trabalho é solo ou em grupo. Além de se utilizar um software de gerenciamento de códigos (eg., <a href="http://www.nongnu.org/cvs/" target="_blank">CVS</a>, <a href="https://subversion.apache.org" target="_blank">Subversion</a>, <a href="http://git-scm.com" target="_blank">git</a>), à medida em que o(s) código(s) cresce(m), torna-se necessário (e desejável também), a utilização de algum software para o gerenciamento do projeto (eg., <a href="http://www.redmine.org" target="_blank">Redmine</a>, <a href="http://trac.edgewall.org" target="_blank">Trac</a>). Mas no meio disso tudo - na verdade, antes disso tudo, há um pequeno pedaço de software que é responsável pela organização hierárquica de todo o projeto. Estamos falando sobre o <a href="https://www.gnu.org/software/make/manual/html_node/Makefiles.html" target="_blank">Makefile</a>.</p>
<p><!--more--></p>
<p>O Makefile é o arquivo lido pelo comando "make" (ou GNUmakefile, se estivermos utilizando o comando "gmake") e é ele quem vai dizer para o compilador por onde começar e como compilar o código. Obviamente, se temos apenas uma rotina (eg., exemplo.f90, ou exemplo.coloqueaquiasualinguagempreferida), não há necessidade de se construir um Makefile (a menos que você precise lincar contra várias bibliotecas - libraries, e incluir vários cabeçalhos - headers). Para o caso mais simples, fazemos a seguinte compilação (utilizando a linguagem fortran e a suíte GCC como exemplo):</p>
<pre>$ gfortran exemplo.f90</pre>
<p>Se o programa exemplo.f90 não contiver erros, como resultado obteremos um executável de nome "a.out". Para executá-lo, basta fazer:</p>
<pre>$ ./a.out</pre>
<p>Caso queiramos especificar um nome diferente para o executável, podemos fazê-lo com a opção "-o":</p>
<pre>$ gfortran exemplo.f90 -o exemplo.x</pre>
<p>Nesse caso, ao invés de obtermos um executável com o nome padrão "a.out", o compilador (no nosso caso, o gfortran) vai gerar um executável com o nome "exemplo.x". É possível especificar qualquer nome, desde que este não contenha espaços e/ou caracteres especiais.</p>
<p>Podemos considerar também a situação em que o programa exemplo.f90 faz referência a um módulo que está escrito dentro de uma outra rotina de nome "modulo.f90". Neste caso, para que possamos gerar um executável para o programa principal (exemplo.f90), podemos fazer da seguinte maneira:</p>
<pre>$ gfortran -c modulo.f90 exemplo.f90</pre>
<pre>$ gfortran modulo.o exemplo.o -o exemplo.x</pre>
<p>Observe que desta vez, utilizamos a opção "-c" do compilador ( assim como a opção "-o", essa opção deve funcionar para qualquer compilador). A opção "-c" faz com que o compilador, ao invés de gerar um executável, crie dois arquivos diferentes para cada arquivo fonte compilado: um com a extensão ".mod" e outro com a extensão ".o". O primeiro, é um arquivo binário que contém todas as instruções específicas daquele módulo. O segundo é um objeto que pode ser utilizado para compor uma biblioteca (geralmente com a extensão ".a"). Imagine que a rotina module.f90 contenha vários módulos. Quando você a compilar com a opção "-c", o compilador vai gerar um par de arquivos ".mod" e ".o" para cada um dos módulos contidos na rotina modulo.f90. Neste caso, a compilação seria feita da mesma forma acima, e é neste tipo de situação (também) que o Makefile cumpre o seu papel.</p>
<p>Então, um Makefile mínimo é aquele que vai resolver o seu problema sem exigir muitos conhecimentos sobre o assunto.</p>
<p>Mas antes, para tornar este exemplo um pouco mais palpável, vamos considerar o seguinte:</p>
<ul>
<li>exemplo.f90 - é o programa principal;</li>
<li>modulo1.f90 - é o módulo 1, que pode conter vários módulos e funções embutidas;</li>
<li>modulo2.f90 - é o módulo 2, que pode conter vários módulos e funções embutidas;</li>
<li>modulo3.f90 - é o módulo 3, que pode conter vários módulos e funções embutidas;</li>
</ul>
<p>Tudo o que você precisa saber para construir manualmente o seu Makefile é a seguinte sintaxe (e sim, há alguns programas que criam os Makefiles automaticamente, como por exemplo, o <a href="http://hpux.connect.org.uk/hppd/hpux/Misc/fgen-0.3/" target="_blank">fgen</a>):</p>
<p>[code language="bash"]<br />
alvo: dependências<br />
[TAB] comandos<br />
[/code]</p>
<p>Só isso. Observe bem que os parágrafos - ou melhor, a identação dentro do Makefile, é feita com a tecla TAB e nunca com espaços.</p>
<p>Então, para escrever o seu Makefile, abra o se editor de textos preferido e digite as seguintes instruções (na mesma ordem) abaixo:</p>
<p>[code language="bash"]<br />
OBJS = modulo1.o modulo2.o modulo3.o exemplo.o<br />
FC = gfortran<br />
RM = rm<br />
main: $(OBJS)<br />
        $(FC) -o exemplo.x $(OBJS)<br />
%.o: %.f90<br />
        $(FC) -c $&amp;lt;<br />
clean:<br />
        $(RM) *.o *.mod exemplo.x<br />
[/code]</p>
<p>A primeira linha do Makefile com a variável "OBJS", faz referências a todos os objetos de todos os arquivos fontes (incluindo o programa principal) que serão criados. Na segunda linha, a variável "FC" refere-se ao compilador que será utilizado (que no nosso caso, é o gfortran). Na próxima linha, fazemos referência ao programa "rm", utilizando uma variável de nome "RM". Observe que, eventualmente, pode ser uma boa idéia especificar o caminho absoluto, ou seja, ao invés de indicar apenas "FC = gfortran" e "RM = rm", pode-se indicar "FC = /usr/bin/gfortran"  e "RM = /usr/bin/rm". Estes caminhos podem mudar de sistema para sistema. Para saber onde se encontram estes comandos no seu Shell, basta utilizar o comando "which" (por exemplo, "which gfortran" e "which rm"). Além disso, o Makefile acima contém duas funções: a primeira, é a função "main" que se encarrega de criar os objetos necessários para a compilação da rotina exemplo.f90; a segunda função "clean" é a responsável por apagar ou "limpar" a compilação. Observe que neste caso, a função "clean" vai apagar qualquer arquivo com extensão ".o", ".mod" e também o executável do programa principal "exemplo.x". Você pode querer utilizar esta função quando for necessário fornecer o seu código para alguém.</p>
<p>Observe também as seguintes instruções contidas nesse Makefile:</p>
<p>[code language="bash"]<br />
%.o: %.f90<br />
        $(FC) -c $&amp;lt;<br />
[/code]</p>
<p>É esta instrução que indica que os objetos devem ser gerados a partir de todos os arquivos com a extensão ".f90". Se o seu projeto possui arquivos com a extensão ".F90" (maiúsculo - neste caso, o seu programa pode conter instruções de pré-processamento, como instruções em <a href="http://en.wikipedia.org/wiki/Message_Passing_Interface" target="_blank">MPI</a> etc), a partir dos quais você queira também criar os objetos, então basta acrescentar:</p>
<p>[code language="bash"]<br />
%.o: %.f90<br />
        $(FC) -c $&amp;lt;<br />
%.o: %.F90<br />
        $(FC) -c $&amp;lt;<br />
[/code]</p>
<p>Para utilizar este Makefile, basta digitar "make" para então compilar o seu projeto ou "make clean" para apagar os arquivos ".mod" e ".o". Estes comando devem ser executados na mesma pasta em que o Makefile estiver:</p>
<pre>$ make</pre>
<pre>$ make clean</pre>
<p>Você pode ainda querer renomear o arquivo Makefile para um outro nome. Neste caso, basta utilizar o modificador "-f" do comando make e indicar o arquivo:</p>
<pre>$ make -f MeuMakefile</pre>
<p>Ok, mas afinal, qual é a vantagem de um Makefile? Se o seu projeto é muito complexo, contendo vários programas, módulos e etc, certamente a compilação também é complexa. Se você quiser fazer uma pequena alteração em um módulo qualquer, ou em um outro programa qualquer dentro do seu projeto, a menos que você esteja utilizando um Makefile, você vai ter que compilar todas as rotinas novamente, para criar todos os objetos novamente e possivelmente, todas as bibliotecas também. Então, como o Makefile sabe quais são as rotinas que precisam ser compiladas, quais os objetos que devem ser criados e quais são as instruções para a compilação, logo, quando você fizer uma alteração qualquer no seu projeto, ele vai compilar apenas aquelas rotinas que foram modificadas. Isso reduz muito o tempo de compilação e ajuda a evitar erros.</p>
<p>É isso!</p>
<p><strong>Referências:</strong></p>
<ul>
<li><a href="http://www.cs.swarthmore.edu/~newhall/unixhelp/howto_makefiles.html" target="_blank">http://www.cs.swarthmore.edu/~newhall/unixhelp/howto_makefiles.html</a></li>
<li><a href="http://kiwi.atmos.colostate.edu/fortran/docs/fortran90-mar30.pdf" target="_blank">http://kiwi.atmos.colostate.edu/fortran/docs/fortran90-mar30.pdf</a></li>
<li><a href="https://www.gnu.org/software/make/manual/html_node/Makefiles.html" target="_blank">https://www.gnu.org/software/make/manual/html_node/Makefiles.html</a></li>
<li><a href="http://www.veryarm.com/1226.html" target="_blank">http://www.veryarm.com/1226.html</a> (link para a imagem em destaque)</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
